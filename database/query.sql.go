// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const addTeam = `-- name: AddTeam :execlastid
INSERT INTO Team (name) VALUES (?)
`

func (q *Queries) AddTeam(ctx context.Context, name string) (int64, error) {
	result, err := q.exec(ctx, q.addTeamStmt, addTeam, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const addUserToTeam = `-- name: AddUserToTeam :execrows
INSERT INTO UserToTeam (user_id, team_id) VALUES (?, ?)
`

type AddUserToTeamParams struct {
	UserID uint32 `json:"userId"`
	TeamID uint32 `json:"teamId"`
}

func (q *Queries) AddUserToTeam(ctx context.Context, arg AddUserToTeamParams) (int64, error) {
	result, err := q.exec(ctx, q.addUserToTeamStmt, addUserToTeam, arg.UserID, arg.TeamID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countTeamByID = `-- name: CountTeamByID :one
SELECT COUNT(*) FROM Team WHERE id=?
`

func (q *Queries) CountTeamByID(ctx context.Context, id uint32) (int64, error) {
	row := q.queryRow(ctx, q.countTeamByIDStmt, countTeamByID, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserByEmail = `-- name: CountUserByEmail :one
SELECT COUNT(*) FROM User WHERE email=?
`

func (q *Queries) CountUserByEmail(ctx context.Context, email string) (int64, error) {
	row := q.queryRow(ctx, q.countUserByEmailStmt, countUserByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserByID = `-- name: CountUserByID :one
SELECT COUNT(*) FROM User WHERE id=?
`

func (q *Queries) CountUserByID(ctx context.Context, id uint32) (int64, error) {
	row := q.queryRow(ctx, q.countUserByIDStmt, countUserByID, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefreshToken = `-- name: CreateRefreshToken :execrows
REPLACE INTO RefreshToken (user_id, token) VALUES (?, ?)
`

type CreateRefreshTokenParams struct {
	UserID uint32 `json:"userId"`
	Token  string `json:"token"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (int64, error) {
	result, err := q.exec(ctx, q.createRefreshTokenStmt, createRefreshToken, arg.UserID, arg.Token)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createUser = `-- name: CreateUser :execlastid
INSERT INTO User (email, first_name, last_name) VALUES (?, ?, ?)
`

type CreateUserParams struct {
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	result, err := q.exec(ctx, q.createUserStmt, createUser, arg.Email, arg.FirstName, arg.LastName)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteRefreshTokenByUserID = `-- name: DeleteRefreshTokenByUserID :execrows
DELETE FROM RefreshToken WHERE user_id=?
`

func (q *Queries) DeleteRefreshTokenByUserID(ctx context.Context, userID uint32) (int64, error) {
	result, err := q.exec(ctx, q.deleteRefreshTokenByUserIDStmt, deleteRefreshTokenByUserID, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTeamByID = `-- name: DeleteTeamByID :execrows
DELETE FROM Team WHERE id=?
`

func (q *Queries) DeleteTeamByID(ctx context.Context, id uint32) (int64, error) {
	result, err := q.exec(ctx, q.deleteTeamByIDStmt, deleteTeamByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteUserByID = `-- name: DeleteUserByID :execrows
DELETE FROM User WHERE id=?
`

func (q *Queries) DeleteUserByID(ctx context.Context, id uint32) (int64, error) {
	result, err := q.exec(ctx, q.deleteUserByIDStmt, deleteUserByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllTeamMembers = `-- name: GetAllTeamMembers :many
SELECT u.id, u.email, u.first_name, u.last_name FROM Team t
JOIN UserToTeam utt ON t.id=utt.team_id
JOIN User u ON u.id=utt.user_id 
WHERE t.id=?
`

type GetAllTeamMembersRow struct {
	ID        uint32 `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

func (q *Queries) GetAllTeamMembers(ctx context.Context, id uint32) ([]GetAllTeamMembersRow, error) {
	rows, err := q.query(ctx, q.getAllTeamMembersStmt, getAllTeamMembers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTeamMembersRow{}
	for rows.Next() {
		var i GetAllTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshTokenByUserID = `-- name: GetRefreshTokenByUserID :one
SELECT id, user_id, token, revoked FROM RefreshToken WHERE user_id=?
`

func (q *Queries) GetRefreshTokenByUserID(ctx context.Context, userID uint32) (RefreshToken, error) {
	row := q.queryRow(ctx, q.getRefreshTokenByUserIDStmt, getRefreshTokenByUserID, userID)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Revoked,
	)
	return i, err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT id, name FROM Team WHERE id=?
`

func (q *Queries) GetTeamByID(ctx context.Context, id uint32) (Team, error) {
	row := q.queryRow(ctx, q.getTeamByIDStmt, getTeamByID, id)
	var i Team
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, first_name, last_name, msft_home_account_id FROM User WHERE email=?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MsftHomeAccountID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, first_name, last_name, msft_home_account_id FROM User WHERE id=?
`

func (q *Queries) GetUserByID(ctx context.Context, id uint32) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MsftHomeAccountID,
	)
	return i, err
}

const getUsersTeams = `-- name: GetUsersTeams :many
SELECT t.id, t.name FROM UserToTeam utt
JOIN Team t ON utt.team_id=t.id 
WHERE utt.user_id=?
`

func (q *Queries) GetUsersTeams(ctx context.Context, userID uint32) ([]Team, error) {
	rows, err := q.query(ctx, q.getUsersTeamsStmt, getUsersTeams, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name FROM Team
WHERE name = ifnull(?, name)
`

func (q *Queries) ListTeams(ctx context.Context, name interface{}) ([]Team, error) {
	rows, err := q.query(ctx, q.listTeamsStmt, listTeams, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, first_name, last_name FROM User
WHERE email = ifnull(?, email)
   AND first_name = ifnull(?, first_name)
   AND last_name = ifnull(?, last_name)
`

type ListUsersParams struct {
	Email     interface{} `json:"email"`
	FirstName interface{} `json:"firstName"`
	LastName  interface{} `json:"lastName"`
}

type ListUsersRow struct {
	ID        uint32 `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers, arg.Email, arg.FirstName, arg.LastName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserHomeAccountID = `-- name: UpdateUserHomeAccountID :execrows
UPDATE User SET msft_home_account_id=? WHERE id=?
`

type UpdateUserHomeAccountIDParams struct {
	MsftHomeAccountID sql.NullString `json:"msftHomeAccountId"`
	ID                uint32         `json:"id"`
}

func (q *Queries) UpdateUserHomeAccountID(ctx context.Context, arg UpdateUserHomeAccountIDParams) (int64, error) {
	result, err := q.exec(ctx, q.updateUserHomeAccountIDStmt, updateUserHomeAccountID, arg.MsftHomeAccountID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
